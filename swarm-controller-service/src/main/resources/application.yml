spring:
  application:
    name: ${SPRING_APPLICATION_NAME:swarm-controller-service}
  rabbitmq:
    host: ${SPRING_RABBITMQ_HOST}
    port: ${SPRING_RABBITMQ_PORT}
    username: ${SPRING_RABBITMQ_USERNAME}
    password: ${SPRING_RABBITMQ_PASSWORD}
    virtual-host: ${SPRING_RABBITMQ_VIRTUAL_HOST}
    listener:
      simple:
        default-requeue-rejected: false
  datasource:
    hikari:
      maximum-pool-size: ${POCKETHIVE_DATASOURCE_HIKARI_MAX_POOL_SIZE:2}
      minimum-idle: ${POCKETHIVE_DATASOURCE_HIKARI_MIN_IDLE:0}
      idle-timeout: ${POCKETHIVE_DATASOURCE_HIKARI_IDLE_TIMEOUT_MS:60000}
      max-lifetime: ${POCKETHIVE_DATASOURCE_HIKARI_MAX_LIFETIME_MS:300000}
      connection-timeout: ${POCKETHIVE_DATASOURCE_HIKARI_CONNECTION_TIMEOUT_MS:5000}
      validation-timeout: ${POCKETHIVE_DATASOURCE_HIKARI_VALIDATION_TIMEOUT_MS:5000}
      connection-test-query: SELECT 1
      leak-detection-threshold: ${POCKETHIVE_DATASOURCE_HIKARI_LEAK_DETECTION_MS:0}

# Include traceId from MDC in log output
logging:
  config: classpath:logback-spring.xml
  pattern:
    level: "%5p [%X{traceId}]"

pockethive:
  journal:
    sink: ${POCKETHIVE_JOURNAL_SINK:postgres}
    run-id: ${POCKETHIVE_JOURNAL_RUN_ID}
  control-plane:
    exchange: ${POCKETHIVE_CONTROL_PLANE_EXCHANGE}
    control-queue-prefix: ${POCKETHIVE_CONTROL_PLANE_CONTROL_QUEUE_PREFIX}
    swarm-id: ${POCKETHIVE_CONTROL_PLANE_SWARM_ID}
    instance-id: ${POCKETHIVE_CONTROL_PLANE_INSTANCE_ID}
    worker:
      enabled: ${POCKETHIVE_CONTROL_PLANE_WORKER_ENABLED}
    manager:
      enabled: true
      role: ${POCKETHIVE_CONTROL_PLANE_MANAGER_ROLE}
    swarm-controller:
      traffic:
        queue-prefix: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_TRAFFIC_QUEUE_PREFIX}
        hive-exchange: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_TRAFFIC_HIVE_EXCHANGE}
      rabbit:
        logs-exchange: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_RABBIT_LOGS_EXCHANGE}
        logging:
          enabled: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_RABBIT_LOGGING_ENABLED}
      metrics:
        pushgateway:
          enabled: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_ENABLED:false}
          base-url: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_BASE_URL:http://pushgateway:9091}
          push-rate: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_PUSH_RATE:10s}
          shutdown-operation: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_SHUTDOWN_OPERATION:DELETE}
          job: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_JOB:swarm-controller}
          grouping-key:
            instance: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_GROUPING_KEY_INSTANCE:${POCKETHIVE_CONTROL_PLANE_INSTANCE_ID}}
      docker:
        socket-path: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_DOCKER_SOCKET_PATH}
      features:
        buffer-guard-enabled: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_FEATURES_BUFFER_GUARD_ENABLED:true}

management:
  prometheus:
    metrics:
      export:
        pushgateway:
          enabled: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_ENABLED:false}
          base-url: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_BASE_URL:http://pushgateway:9091}
          push-rate: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_PUSH_RATE:10s}
          shutdown-operation: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_SHUTDOWN_OPERATION:DELETE}
          job: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_JOB:swarm-controller}
          grouping-key:
            instance: ${POCKETHIVE_CONTROL_PLANE_SWARM_CONTROLLER_METRICS_PUSHGATEWAY_GROUPING_KEY_INSTANCE:${POCKETHIVE_CONTROL_PLANE_INSTANCE_ID}}
